#--------------------------------poistettavat-----------------------------------
irmovq $0x1800, %r8         # testattavien arvojen alku muistissa

#POISTA .pos0x1800 ja quad käskyt lopusta

#------------------------------------main---------------------------------------

main:
    irmovq pino,%rbp        # pinon alkuosoite 
    irmovq pino,%rsp        # pinon ylimmän muistipaikan osoite

    call loop               # tarkistetaan yksi kerrallaan

    halt
    
loop:
    mrmovq (%r8),%rcx       # haetaan käsiteltävä luku
    irmovq $0,%r9           # tarkistetaan, onko 0
    addq %rcx,%r9           # ...
    je loppu                # jos on, saavutettiin listan loppu
    call parillinen         # tarkistetaan, onko parillinen
    irmovq $0,%r9           # testataan, saatiinko -1 eli parillinen
    addq %rcx,%r9           # ...
    jl seuraava             # jos saatiin, siirrytään seuraavaan lukuun
    call loopmillerrabin    # muussa tapauksessa käytetään algoritmia
    jmp seuraava            # jos ohjelma palaa, siirrytään seuraavaan lukuun
    
seuraava:
    irmovq $8, %r9          # siirrytään seuraavaan muistipaikkaan
    addq %r9, %r8           # ...
    jmp loop
    
parillinen:
    irmovq $2,%r10          # tarkistetaan, onko 2
    subq %rcx,%r10          # ...
    je prime                # jos 2, saatiin vastaus
    rrmovq %rcx,%rdx        # otetaan kopio
    irmovq $0x01,%r9        # maski
    andq %r9,%rdx           # otetaan viimeinen bitti
    irmovq $0,%r10          # tarkistetaan, onko viimeinen 0 eli parillinen
    addq %rdx,%r10          # ...
    je onparillinen         # jos parillinen
    ret                     # jos ei, palataan looppiin

prime:
    rrmovq %rcx,%rax
    halt                    # lopetetaan suoritus ja palautetaan 2
    
onparillinen:               # kyseessä parillinen luku
    irmovq $-1,%rcx         # palautetaan -1 merkiksi, että ei ole prime
    ret
    
done:                       # kyseinen subroutine on valmis
    ret

loppu:                      # saavutettiin listassa 0
    halt
    
composite:                  # kyseessä composite luku
    ret

loopmillerrabin:            # testataan kaikille eri witnesseille
    irmovq $2,%r8          # witness
    call millerrabin
    irmovq $3,%r8          # witness
    call millerrabin
    irmovq $5,%r8          # witness
    call millerrabin
    irmovq $7,%r8          # witness
    call millerrabin
    irmovq $11,%r8         # witness
    call millerrabin
    irmovq $13,%r8         # witness
    call millerrabin
    irmovq $17,%r8         # witness
    call millerrabin
    irmovq $19,%r8         # witness
    call millerrabin
    irmovq $23,%r8         # witness
    call millerrabin
    irmovq $29,%r8         # witness
    call millerrabin
    irmovq $31,%r8         # witness
    call millerrabin
    irmovq $37,%r8         # witness
    call millerrabin
    ret

millerrabin:                # millerrabin algoritmi
    rrmovq %rcx,%r9         # otetaan kopio luvusta
    irmovq $1, %rdx         # p = number - 1;
    subq %rdx,%r9           # ...
    
    rrmovq %rcx,%r10        # annetaan argumentti, r8 ja r9 on valmiina
    pushq %rcx              # tallennetaan pääohjelman arvot
    pushq %r9               # ...
    pushq %r8               # ...
    call eksmod             # modpow(witness, p, number)
    popq %r8                # palautetaan pääohjelman arvot
    popq %r9                # ...
    popq %rcx               # ...
    irmovq $1,%rdx          # if (modpow(witness, p, number) != 1)
    subq %rax,%rdx          # ...
    jne composite           # return COMPOSITE
    
    
     
    
    ret
    
#int miller_rabin_round(const u64 number, const u64 witness)
#{
#	u64 p = number - 1;
#
#	if (modpow(witness, p, number) != 1)
#		return COMPOSITE;
#
#	for (;;) {
#		if (p & 1)
#			return PRIME;
#		p = halve(p);
#		const u64 result = modpow(witness, p, number);
#
#		if (result == 1)
#			continue;
#		else if (result == number - 1)
#			return PRIME;
#		else
#			return COMPOSITE;
#	}

#-----------------------------eksponenttimodulo---------------------------------
#käyttää kaikkia rekistereitä pinorekistereitä lukuun ottamatta
#argumentit:
# %r8 = kanta
# %r9 = eksponentti 
# %r10 = modulo
#välitulokset:
# vastaus = %rcx
# kanta = %rdx
#vastaus: 
# %rax

eksmod:
    call kanta              # kanta := kanta % modulo
    irmovq $1,%rcx          # vastaus = 1
    call loope              # for jokainen bitti eksponentissa LSB -> MSB:
    ret

kanta:
    rrmovq %r8,%r11         # laitetaan argumentit pinoon
    rrmovq %r10,%r12        # ...
    call modulo             # suoritetaan modulo
    rrmovq %rax,%rdx        # tallennetaan vastaus
    ret
    
loope:
    irmovq $0x01,%rbx       # maski, pienin bitti
    jmp loope1
    
loope1:                     # tarkistetaan bitti
    rrmovq %r9,%r13         # kopio eksponentista
    andq %rbx,%r13          # otetaan yksi bitti
    je loope2               # bitti on nolla
    call lasku              # suoritetaan jos bitti on yksi
        
loope2:                     # siirrytään seuraavaan
    addq %rbx,%rbx          # siirretään maski seuraavaan bittiin
    rrmovq %r9,%r13         # kopio eksponentista
    subq %rbx,%r13          # testataan, onko maski isompi kuin eksponentti
    jl doneloope            # jos on, valmis
    call lasku2             # suoritetaan aina
    jmp loope1              # jos ei, mennään käsittelemään seuraava bitti

doneloope:
    rrmovq %rcx,%rax        #tallennetaan vastaus
    ret

lasku:                      # vastaus := vastaus * kanta % modulo
    rrmovq %rcx,%r11        # annetaan argumentit 
    rrmovq %rdx,%r12        # ...
    call kertolasku         # suoritetaan vastaus = vastaus * kanta
    rrmovq %rax,%rcx        # tallennetaan vastaus

    rrmovq %rcx,%r11        # annetaan argumentit
    rrmovq %r10,%r12        # ...
    call modulo             # suoritetaan vastaus = vastaus % modulo
    rrmovq %rax,%rcx        # tallennetaan vastaus
    ret

lasku2:                     # kanta := kanta * kanta % modulo
    rrmovq %rdx,%r11        # annetaan argumentit
    rrmovq %rdx,%r12        # ...
    call kertolasku         # suoritetaan kanta = kanta * kanta
    rrmovq %rax,%rdx        # tallennetaan vastaus

    rrmovq %rdx,%r11        # annetaan argumentit
    rrmovq %r10,%r12        # ...
    call modulo             # suoritetaan kanta = kanta % modulo
    rrmovq %rax,%rdx        # tallennetaan vastaus
    ret

#-----------------------------------modulo--------------------------------------
#käyttää rekistereitä r11, r12, r13 ja rax
#argumentit:
# %r11 = kanta / jaettava
# %r12 = modulo / jakaja
#vastaus:
# %rax

modulo:
    irmovq $0,%r13          # tarkistetaan, onko jakaja 0
    addq %r12,%r13          # ...
    je nolla                # jos jakaja on 0
    irmovq $0,%rax          # alustetaan tulos
    pushq %r12              #tallennetaan jakaja
    jmp modulo2
    
modulo2:
    rrmovq %r11,%rax        # tallennetaan mahd. jakojäännös
    subq %r12,%r11          # vähennetään
    jl liiansuuri           # jos liian suuri
    addq %r12,%r12          # muuten siirretään yksi bitti vasemmalle
    jmp modulo2             # toistetaan

liiansuuri:
    rrmovq %rax,%r11        # palautetaan edellinen erotus 
    mrmovq (%rsp),%r12      # palautetaan alkuperäinen jakaja
    subq %r12,%r11          # tarkistetaan onko alkuperäinen liian suuri
    jl donemodulo           # jos on, lasku valmis
    rrmovq %rax,%r11        # muuten palautetaan edellinen erotus
    jmp modulo2             # jatketaan laskua
    
nolla:
    irmovq $0,%rax          # annetaan vastaukseksi 0
    ret
    
donemodulo:
    popq %r12               #poistetaan tallennettu jakaja pinosta
    ret
    
#---------------------------------kertolasku------------------------------------
#käyttää rekistereitä r11, r12, r13, r14, rsi, rdi ja rax
#argumentit:
# %r11 = kertoja
# %r12 = kerrottava
#vastaus:
# %rax

kertolasku:
    irmovq $0x01,%rsi       # maski, pienin bitti
    irmovq $0,%rdi          # bittisiirron laskuri
    irmovq $0,%rax          # alustetaan summa/tulos
    call kertoja            # haetaan argumentit, valitaan kertojaksi pienempi
    irmovq $1,%r14          # vakio 1
    jmp bitit1

kertoja:                    # valitaan kertojaksi pienempi luku
    pushq %r11              # tallennetaan r11
    subq %r12,%r11          # vertailu
    jl oikein               # pienempi on jo kertoja
    rrmovq %r12,%r11        # vaihetaan toisin pain
    popq %r12               # ...
    ret
    
oikein:                     # pidetään alkuperäiset
    popq %r11               # palautetaan %r11 takaisin
    ret

bitit1:                     # ensimmäinen bitti, ei bittisiirtoa
    rrmovq %r11,%r13        # kertojasta kopio
    andq %rsi,%r13          # otetaan yksi bitti
    je maski                # bitti on nolla
    addq %r12,%rax          # lisätään tulokseen
    jmp maski

bitit2:                     # muut bitit ja mahd. bittisiirrot
    rrmovq %r11,%r13        # kertojasta kopio
    andq %rsi,%r13          # otetaan yksi bitti
    je maski                # bitti on nolla
    pushq %rdi              # tallennetaan laskurin arvo
    rrmovq %r12,%r13        # kopio kerrottavasta
    jmp bittisiirto         # tehdään bittien siirto
    
maski:
    addq %rsi,%rsi          # siirretään maski seuraavaan bittiin
    rrmovq %r11,%r13        # kertojasta kopio
    subq %rsi,%r13          # testataan, onko maski isompi kuin kertoja
    jl donekertolasku       # jos on, lasku on valmis
    addq %r14,%rdi          # lisätään yksi bittisiirtolaskuriin
    jmp bitit2              # mennään käsittelemään seuraava bitti
    
bittisiirto: 
    addq %r13,%r13          # siirretään yhdellä vasemmalle
    subq %r14,%rdi          # vähennetään laskurista 1
    jg bittisiirto          # jos laskuri > 0, siirretään uudestaan
    addq %r13,%rax          # kun laskuri = 0, lisätään tulos summaan
    popq %rdi               # palautetaan laskurin arvo ennalleen
    jmp maski       
    
donekertolasku:
    ret

#---------------------------------jako kahdella---------------------------------
#käyttää rekistereitä r8, r9, r10, r11 ja rax
#argumentit:
# %r8 = jaettava
#vastaus: 
# %rax

puolitus:
    irmovq $0x01,%r9    #maski
    irmovq $0x01,%r10   #puolikas
    irmovq $0,%rax      #alustetaan summa
    jmp tarkistae
    
tarkistae:
    addq %r9,%r9        #siirretään maski seuraavaan bittiin
    rrmovq %r8,%r11     #haetaan jaettava
    andq %r9,%r11
    je tarkista         #bitti on 0
    jmp yksi            #bitti on 1
    
tarkista:
    rrmovq %r8,%r11     #tarkistetaan, ollaanko luvun lopussa
    subq %r9,%r11       #jos ollaan, maski on isompi kuin luku
    jl puolitusdone
    addq %r10,%r10      #siirretään puolikas seuraavaan
    addq %r9,%r9        #siirretään maski seuraavaan bittiin
    rrmovq %r8,%r11     #haetaan jaettava
    andq %r9,%r11       #otetaan bitti
    je tarkista         #bitti on 0
    jmp yksi            #bitti on 1

yksi:
    addq %r10,%rax
    jmp tarkista

puolitusdone: 
    ret
    
#-------------------------------------------------------------------------------

.pos 0x500
pino:

.pos 0x1800
.align 8
.quad 9
.quad 7
.quad 0

#-----------------------------------REFLECTION----------------------------------
#Tallensin arvot aina kun mahdollista samoihin rekistereihin, joissa niitä 
#käytettiin aliohjelmissa, jotta välttyy ylimääräisiltä rekisterisiirroilta 
    
