irmovq $32,%r8       # kanta
irmovq $21,%r9       # eksponentti
irmovq $20,%r10      # modulo


#------------------------------main----------------------------------
#laskun argumentit:
# %r8 = kanta
# %r9 = eksponentti 
# %r10 = modulo
#välitulokset:
# vastaus = %rcx
# kanta = %rdx
#lopullinen vastaus: 
# %rax

main:
    irmovq pino,%rbp        # pinon alkuosoite 
    irmovq pino,%rsp        # pinon ylimmän muistipaikan osoite
    call kanta              # kanta := kanta % modulo
    irmovq $1,%rcx          # vastaus = 1
    call loop               # for jokainen bitti eksponentissa LSB -> MSB:
    halt

kanta:
    pushq %r8               # laitetaan argumentit pinoon
    pushq %r10              # ...
    call modulo             # suoritetaan modulo
    rrmovq %rax,%rdx        # tallennetaan vastaus
    irmovq $16,%rsi         # tyhjennetään pino
    addq %rsi,%rsp          # ...
    ret
    
#------------------------------loop----------------------------------

loop:
    irmovq $0x01,%rbx       # maski, pienin bitti
    jmp loop1
    
loop1:                      # tarkistetaan bitti
    rrmovq %r9,%r13         # kopio eksponentista
    andq %rbx,%r13          # otetaan yksi bitti
    je loop2                # bitti on nolla
    call lasku              # suoritetaan jos bitti on yksi
        
loop2:                      # siirrytään seuraavaan
    addq %rbx,%rbx          # siirretään maski seuraavaan bittiin
    rrmovq %r9,%r13         # kopio eksponentista
    subq %rbx,%r13          # testataan, onko maski isompi kuin eksponentti
    jl doneloop             # jos on, valmis
    call lasku2             # suoritetaan aina
    jmp loop1               # jos ei, mennään käsittelemään seuraava bitti

doneloop:
    rrmovq %rcx,%rax        #tallennetaan vastaus
    ret

#------------------------------laskut----------------------------------

lasku:                      # vastaus := vastaus * kanta % modulo
    pushq %rcx              # laitetaan argumentit pinoon
    pushq %rdx              # ...
    call kertolasku         # suoritetaan vastaus = vastaus * kanta
    rrmovq %rax,%rcx        # tallennetaan vastaus
    irmovq $16,%rsi         # tyhjennetään pino
    addq %rsi,%rsp          # ...
    
    pushq %rcx              # laitetaan argumentit pinoon
    pushq %r10              # ...
    call modulo             # suoritetaan vastaus = vastaus % modulo
    rrmovq %rax,%rcx        # tallennetaan vastaus
    irmovq $16,%rsi         # tyhjennetään pino
    addq %rsi,%rsp          # ...
    ret

lasku2:                     # kanta := kanta * kanta % modulo
    pushq %rdx              # laitetaan argumentit pinoon
    pushq %rdx              # ...
    call kertolasku         # suoritetaan kanta = kanta * kanta
    rrmovq %rax,%rdx        # tallennetaan vastaus
    irmovq $16,%rsi         # tyhjennetään pino
    addq %rsi,%rsp          # ...
    
    pushq %rdx              # laitetaan argumentit pinoon
    pushq %r10              # ...
    call modulo             # suoritetaan kanta = kanta % modulo
    rrmovq %rax,%rdx        # tallennetaan vastaus
    irmovq $16,%rsi         # tyhjennetään pino
    addq %rsi,%rsp          # ...
    ret

#------------------------------modulo----------------------------------
#kaksi argumenttia
#1: kanta / jaettava, %r11
#2: modulo / jakaja, %r12
#vastaus = %rax

modulo:
    mrmovq 8(%rsp),%r12    # jakaja
    irmovq $0,%r13          # tarkistetaan, onko jakaja 0
    addq %r12,%r13          # ...
    je nolla                # jos jakaja on 0
    mrmovq 16(%rsp),%r11     # jaettava
    irmovq $0,%rax          # alustetaan tulos
    jmp modulo2
    
modulo2:
    rrmovq %r11,%rax        # tallennetaan mahd. jakojäännös
    subq %r12,%r11          # vähennetään
    jl liiansuuri           # jos liian suuri
    addq %r12,%r12          # muuten siirretään yksi bitti vasemmalle
    jmp modulo2             # toistetaan

liiansuuri:
    rrmovq %rax,%r11        # palautetaan edellinen erotus 
    mrmovq 8(%rsp),%r12    # palautetaan alkuperäinen jakaja
    subq %r12,%r11          # tarkistetaan onko alkuperäinen liian suuri
    jl donemodulo           # jos on, lasku valmis
    rrmovq %rax,%r11        # muuten palautetaan edellinen erotus
    jmp modulo2             # jatketaan laskua
    
nolla:
    irmovq $0,%rax          # annetaan vastaukseksi 0
    ret
    
donemodulo:
    ret
    
#------------------------------kertolasku----------------------------------
#kaksi argumenttia
#1: kertoja, %r11
#2: kerrottava, %r12
#vastaus = %rax

kertolasku:
    irmovq $0x01,%rsi       # maski, pienin bitti
    irmovq $0,%rdi          # bittisiirron laskuri
    irmovq $0,%rax          # alustetaan summa/tulos
    call kertoja            # haetaan argumentit, valitaan kertojaksi pienempi
    irmovq $1,%r14          # vakio 1
    jmp bitit1

kertoja:                    # valitaan kertojaksi pienempi luku
    mrmovq 16(%rsp),%r11    # tuodaan luvut pinosta
    mrmovq 24(%rsp),%r12    # ...
    subq %r12,%r11
    jl oikein               # pienempi on jo kertoja
    mrmovq 16(%rsp),%r12    # vaihdetaan toisinpäin
    mrmovq 24(%rsp),%r11    # ...
    ret
    
oikein:
    mrmovq 16(%rsp),%r11    # palautetaan %r11 takaisin
    ret

bitit1:                     # ensimmäinen bitti, ei bittisiirtoa
    rrmovq %r11,%r13        # kertojasta kopio
    andq %rsi,%r13          # otetaan yksi bitti
    je maski                # bitti on nolla
    addq %r12,%rax          # lisätään tulokseen
    jmp maski

bitit2:                     # muut bitit ja mahd. bittisiirrot
    rrmovq %r11,%r13        # kertojasta kopio
    andq %rsi,%r13          # otetaan yksi bitti
    je maski                # bitti on nolla
    pushq %rdi              # tallennetaan laskurin arvo
    rrmovq %r12,%r13        # kopio kerrottavasta
    jmp bittisiirto         # tehdään bittien siirto
    
maski:
    addq %rsi,%rsi          # siirretään maski seuraavaan bittiin
    rrmovq %r11,%r13        # kertojasta kopio
    subq %rsi,%r13          # testataan, onko maski isompi kuin kertoja
    jl donekertolasku       # jos on, lasku on valmis
    addq %r14,%rdi          # lisätään yksi bittisiirtolaskuriin
    jmp bitit2              # mennään käsittelemään seuraava bitti
    
bittisiirto: 
    addq %r13,%r13          # siirretään yhdellä vasemmalle
    subq %r14,%rdi          # vähennetään laskurista 1
    jg bittisiirto          # jos laskuri > 0, siirretään uudestaan
    addq %r13,%rax          # kun laskuri = 0, lisätään tulos summaan
    popq %rdi               # palautetaan laskurin arvo ennalleen
    jmp maski       
    
donekertolasku:
    ret

#----------------------------------------------------------------

.pos 0x500
pino:

done: 
    halt
    
    
